{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Python Eledio library documentation Welcome to Eledio library documentation pages Note This library and documantation can be aplied only for devices from Eledio ecosystem","title":"Home"},{"location":"#python-eledio-library-documentation","text":"Welcome to Eledio library documentation pages","title":"Python Eledio library documentation"},{"location":"#note","text":"This library and documantation can be aplied only for devices from Eledio ecosystem","title":"Note"},{"location":"api_description/","text":"Description of API for python-eledio library This description allow to you easly write your own python script. This script you can use for control of your Eledio devices. This sript you can upload to your Eledio Gateway and control your gateways and your Eledio Extendres which you want control from gateway. This library is preinstalled in your Eledio Gateway . You can start programming, after unpacking. Necessary parts Each major drive script in python for your application must be made up with some necessary parts. device description in json file import of library components load of json file Device description in json file this file is for hardware abstraction layer to linux you are able to used your own names of identifiers, eg. you can rename Temperature to OutsideTemperature every name of identifiers must consist only with English alphabet characters, without spaces and other punctuation if you need some reaclculation of readout values, you can use prepared values a and b , with are parts of equation y=a*x+b , where x is readout value from device, y is value which you obtain in python script, eg. if you need temeperature in degree of fahrenheit, you can place a=1.8 and b=32 (which corresponds of equation T[\u00b0F] = T[\u00b0C]*1.8 + 32 ) Example of json file, can be named as config.json { \"devices\": { \"unit-40\": { \"bus\": \"i2c\", \"address\": 40, \"datacrc\": 9718, \"compilermagic\": 4006394777 } }, \"identifiers\": { \"gatewayHWEvent\": { \"unit\": \"unit-40\", \"partition\": \"sdp\", \"offset\": 0, \"entrysize\": 2, \"depth\": 0, \"type\": 1, \"prescaler\": 0, \"a\": 1, \"b\": 0, \"datatype\": \"u16\", \"srq\": 0 }, \"gatewayHWState\": { \"unit\": \"unit-40\", \"partition\": \"sdp\", \"offset\": 2, \"entrysize\": 2, \"depth\": 0, \"type\": 1, \"prescaler\": 0, \"a\": 1, \"b\": 0, \"datatype\": \"u16\" }, \"RE1Voltage\": { \"unit\": \"unit-40\", \"partition\": \"sdp\", \"offset\": 4, \"entrysize\": 2, \"depth\": 0, \"type\": 1, \"prescaler\": 0, \"a\": 0.01, \"b\": 0, \"datatype\": \"s16\" }, \"Temperature\": { \"unit\": \"unit-40\", \"partition\": \"sdp\", \"offset\": 6, \"entrysize\": 2, \"depth\": 0, \"type\": 1, \"prescaler\": 0, \"a\": 0.01, \"b\": 0, \"datatype\": \"s16\" }, \"gatewayHWAction\": { \"unit\": \"unit-40\", \"partition\": \"adp\", \"offset\": 0, \"entrysize\": 2 }, \"RE1\": { \"unit\": \"unit-40\", \"partition\": \"adp\", \"offset\": 2, \"entrysize\": 1 }, \"RE3\": { \"unit\": \"unit-40\", \"partition\": \"adp\", \"offset\": 3, \"entrysize\": 1 } } } Import of library components consist with few of import statements, which are necessary for correct function import json # necessary for description json file; required from eledio import Eledio # basic functionality; required from eledio.component.mpu.i2c import SMBus # communication interface with linux; required from eledio.device.pcu import PcuFactory # access to variables and components of base board, e.g: relay outputs, digital inputs, ...; required from eledio.device.mpu import MpuFactory # access to variables and components of linux board, e.g.: wifi signal rssi, status LED color, ... from eledio.device.srq import Srq # interrupt system for quick access to variables which need intermediate handle, e.g.: RF433 receiver Load of json file this part is required before fist try of attempt to variables with names form config json part Basic example of device registration eledio = Eledio() eledio.register_device_factory(\"i2c\", PcuFactory(SMBus(0))) # repeat for every configuration file with open('config.json') as f: eledio.append_config(json.load(f)) Readout values from the peripherals - sensors, to linux Everytime, you want to read all of variables, e.g.: temperatures, digital input states, sensors values, ... you must to call eledio.load_inputs() After this calling, you can access to variables by their symbloc names in dict access. For example: eledio.load_inputs() temperature = eledio[\"Temperature\"] # this statement put value of temperature after processing of linear equation (a and b coeficients) to the variable temperature voltage = eledio[\"RE1Voltage\"] # this statement put value of RMS voltage on relay 1 to variable voltage Put new values to the peripherals - actuators, connected to the hardware For relay, digital outputs you are able to set states True/False. Used logic of every component is written in component description. eledio[\"RE1\"] = True # switch on relay 1 eledio[\"RE3\"] = False # switch off relay 3 eledio.store_outputs() After setting values for all of dict eledio parts, which you want to set, you need to call command eledio.store_outputs() , which send that values to real hardware.","title":"API description"},{"location":"api_description/#description-of-api-for-python-eledio-library","text":"This description allow to you easly write your own python script. This script you can use for control of your Eledio devices. This sript you can upload to your Eledio Gateway and control your gateways and your Eledio Extendres which you want control from gateway. This library is preinstalled in your Eledio Gateway . You can start programming, after unpacking.","title":"Description of API for python-eledio library"},{"location":"api_description/#necessary-parts","text":"Each major drive script in python for your application must be made up with some necessary parts. device description in json file import of library components load of json file","title":"Necessary parts"},{"location":"api_description/#device-description-in-json-file","text":"this file is for hardware abstraction layer to linux you are able to used your own names of identifiers, eg. you can rename Temperature to OutsideTemperature every name of identifiers must consist only with English alphabet characters, without spaces and other punctuation if you need some reaclculation of readout values, you can use prepared values a and b , with are parts of equation y=a*x+b , where x is readout value from device, y is value which you obtain in python script, eg. if you need temeperature in degree of fahrenheit, you can place a=1.8 and b=32 (which corresponds of equation T[\u00b0F] = T[\u00b0C]*1.8 + 32 )","title":"Device description in json file"},{"location":"api_description/#example-of-json-file-can-be-named-as-configjson","text":"{ \"devices\": { \"unit-40\": { \"bus\": \"i2c\", \"address\": 40, \"datacrc\": 9718, \"compilermagic\": 4006394777 } }, \"identifiers\": { \"gatewayHWEvent\": { \"unit\": \"unit-40\", \"partition\": \"sdp\", \"offset\": 0, \"entrysize\": 2, \"depth\": 0, \"type\": 1, \"prescaler\": 0, \"a\": 1, \"b\": 0, \"datatype\": \"u16\", \"srq\": 0 }, \"gatewayHWState\": { \"unit\": \"unit-40\", \"partition\": \"sdp\", \"offset\": 2, \"entrysize\": 2, \"depth\": 0, \"type\": 1, \"prescaler\": 0, \"a\": 1, \"b\": 0, \"datatype\": \"u16\" }, \"RE1Voltage\": { \"unit\": \"unit-40\", \"partition\": \"sdp\", \"offset\": 4, \"entrysize\": 2, \"depth\": 0, \"type\": 1, \"prescaler\": 0, \"a\": 0.01, \"b\": 0, \"datatype\": \"s16\" }, \"Temperature\": { \"unit\": \"unit-40\", \"partition\": \"sdp\", \"offset\": 6, \"entrysize\": 2, \"depth\": 0, \"type\": 1, \"prescaler\": 0, \"a\": 0.01, \"b\": 0, \"datatype\": \"s16\" }, \"gatewayHWAction\": { \"unit\": \"unit-40\", \"partition\": \"adp\", \"offset\": 0, \"entrysize\": 2 }, \"RE1\": { \"unit\": \"unit-40\", \"partition\": \"adp\", \"offset\": 2, \"entrysize\": 1 }, \"RE3\": { \"unit\": \"unit-40\", \"partition\": \"adp\", \"offset\": 3, \"entrysize\": 1 } } }","title":"Example of json file, can be named as  config.json"},{"location":"api_description/#import-of-library-components","text":"consist with few of import statements, which are necessary for correct function import json # necessary for description json file; required from eledio import Eledio # basic functionality; required from eledio.component.mpu.i2c import SMBus # communication interface with linux; required from eledio.device.pcu import PcuFactory # access to variables and components of base board, e.g: relay outputs, digital inputs, ...; required from eledio.device.mpu import MpuFactory # access to variables and components of linux board, e.g.: wifi signal rssi, status LED color, ... from eledio.device.srq import Srq # interrupt system for quick access to variables which need intermediate handle, e.g.: RF433 receiver","title":"Import of library components"},{"location":"api_description/#load-of-json-file","text":"this part is required before fist try of attempt to variables with names form config json part","title":"Load of json file"},{"location":"api_description/#basic-example-of-device-registration","text":"eledio = Eledio() eledio.register_device_factory(\"i2c\", PcuFactory(SMBus(0))) # repeat for every configuration file with open('config.json') as f: eledio.append_config(json.load(f))","title":"Basic example of device registration"},{"location":"api_description/#readout-values-from-the-peripherals-sensors-to-linux","text":"Everytime, you want to read all of variables, e.g.: temperatures, digital input states, sensors values, ... you must to call eledio.load_inputs() After this calling, you can access to variables by their symbloc names in dict access. For example: eledio.load_inputs() temperature = eledio[\"Temperature\"] # this statement put value of temperature after processing of linear equation (a and b coeficients) to the variable temperature voltage = eledio[\"RE1Voltage\"] # this statement put value of RMS voltage on relay 1 to variable voltage","title":"Readout values from the peripherals - sensors, to linux"},{"location":"api_description/#put-new-values-to-the-peripherals-actuators-connected-to-the-hardware","text":"For relay, digital outputs you are able to set states True/False. Used logic of every component is written in component description. eledio[\"RE1\"] = True # switch on relay 1 eledio[\"RE3\"] = False # switch off relay 3 eledio.store_outputs() After setting values for all of dict eledio parts, which you want to set, you need to call command eledio.store_outputs() , which send that values to real hardware.","title":"Put new values to the peripherals - actuators, connected to the hardware"},{"location":"application_example/","text":"Example of usages There you can find some examples, how to use python-eledio library in your Eledio devices. State LED, buzzer and watchdog control Configuration json file File name: mpu-config.json { \"devices\": { \"mpu-dev\": { \"bus\": \"mpu\" } }, \"identifiers\": { \"mpuWifiRssi\": { \"unit\": \"mpu-dev\", \"parameter\": \"wifi-rssi\" }, \"mpuInternalTemperature\": { \"unit\": \"mpu-dev\", \"parameter\": \"temperature\" }, \"mpuCpuPercent\": { \"unit\": \"mpu-dev\", \"parameter\": \"cpu-percent\" }, \"mpuLed\": { \"unit\": \"mpu-dev\", \"parameter\": \"led\" }, \"mpuBeeper\": { \"unit\": \"mpu-dev\", \"parameter\": \"beeper\" }, \"mpuWatchdog\": { \"unit\": \"mpu-dev\", \"parameter\": \"watchdog\" } } } Usage import json from eledio import Eledio from eledio.component.mpu.i2c import SMBus from eledio.device.mpu import MpuFactory if __name__ == \"__main__\": eledio = Eledio() eledio.register_device_factory(\"mpu\", MpuFactory()) with open('mpu-config.json') as f: eledio.append_config(json.load(f)) eledio[\"mpuLed\"] = (0x40, 0x00, 0x00) # set color of state LED in (R, G, B) format eledio[\"mpuBeeper\"] = (1500, 10) # after calling store_outputs() switch on beeper on frequency 1500 Hz for 1s (first parameter is frequency in Hz, second parameter is duration in hundred ms) ''' Warning, next statement is dangerous, it couse restart of linux machine (watchdog). This function is good to use when you have your development complete, and you know, that you communicate with components and devices lower then every x second. ''' eledio[\"mpuWatchdog\"] = 120 # after calling store_outputs() this statement couse reset of linux every 120 seconds. If there is any communication with devicese, timeout is restarted. eledio.store_outputs() WiFi RSSI, linux CPU utilization Use same json file as in previous example. Usage import json from eledio import Eledio from eledio.component.mpu.i2c import SMBus from eledio.device.mpu import MpuFactory if __name__ == \"__main__\": eledio = Eledio() eledio.register_device_factory(\"mpu\", MpuFactory()) with open('mpu-config.json') as f: eledio.append_config(json.load(f)) eledio.load_inputs() rssi = eledio[\"mpuWifiRssi\"] # place to variable rssi, WiFi signal RSSI utilization = eledio[\"mpuCpuPercent\"] # place to variable utilitation, linux CPU utilization SRQ/IRQ handler If you want to used quick access to variables like received code from RF433 control, you can use SRQ handler. Inside SRQ handler, in this example function handle_srq , you received dictionary of eledio identifiers and their new value after SRQ. Configuration json file File name: map.json { \"devices\": { \"unit-40\": { \"bus\": \"i2c\", \"address\": 40, \"datacrc\": 43200, \"compilermagic\": 4006394777 } }, \"identifiers\": { \"gatewayHWEvent\": { \"unit\": \"unit-40\", \"partition\": \"sdp\", \"offset\": 0, \"entrysize\": 2, \"depth\": 0, \"type\": 1, \"prescaler\": 0, \"a\": 1, \"b\": 0, \"datatype\": \"u16\", \"srq\": 0 }, \"gatewayHWState\": { \"unit\": \"unit-40\", \"partition\": \"sdp\", \"offset\": 2, \"entrysize\": 2, \"depth\": 0, \"type\": 1, \"prescaler\": 0, \"a\": 1, \"b\": 0, \"datatype\": \"u16\" }, \"rf433\": { \"unit\": \"unit-40\", \"partition\": \"sdp\", \"offset\": 4, \"entrysize\": 4, \"depth\": 0, \"type\": 1, \"prescaler\": 0, \"a\": 1, \"b\": 0, \"datatype\": \"u32\", \"srq\": 1 }, \"gatewayHWAction\": { \"unit\": \"unit-40\", \"partition\": \"adp\", \"offset\": 0, \"entrysize\": 2 } } } Usage import json from eledio import Eledio from eledio.component.mpu.i2c import SMBus from eledio.device.mpu import MpuFactory def handle_srq(identifiers): \"\"\" User handling of SRQ (called in context of eledio.wait_events) :param identifiers: dictionary of eledio identifiers and their new value after SRQ :return: \"\"\" print(\"Service requests!\", identifiers) if __name__ == \"__main__\": eledio = Eledio() eledio.register_device_factory(\"i2c\", PcuFactory(SMBus(0))) eledio.register_srq(Srq(), handle_srq()) # repeat for every configuration file with open('map.json') as f: eledio.append_config(json.load(f)) while True: # load state of inputs and outputs eledio.load_inputs() # do something else or wait some time eledio.wait_events(1.0) Error handler In runtime and while you develop your solution, there could rise some errors. You can catch them by definition of error handler . Usage In this example error handler is represented by function handler_error . import json from eledio import Eledio from eledio.component.mpu.i2c import SMBus from eledio.device.pcu import PcuFactory from eledio.device.mpu import MpuFactory from eledio.device.srq import Srq def handle_srq(identifiers): \"\"\" User handling of SRQ (called in context of eledio.wait_events) :param identifiers: dictionary of eledio identifiers and their new value after SRQ :return: \"\"\" print(\"Service requests!\", identifiers) def handle_error(src, ex): \"\"\" Handle error inside eledio library :param src: :param ex: :return: \"\"\" print(src, ex) if __name__ == \"__main__\": eledio = Eledio() eledio.register_device_factory(\"i2c\", PcuFactory(SMBus(0))) eledio.register_device_factory(\"mpu\", MpuFactory()) eledio.register_srq(Srq(), handle_srq) eledio.error_handler = handle_error # repeat for every configuration file with open('config.json') as f: eledio.append_config(json.load(f)) with open('mpu-config.json') as f: eledio.append_config(json.load(f)) while True: # load state of inputs and outputs eledio.load_inputs() # manipulate with inputs and outputs by identifier # e.g. # print(eledio[\"test1\"]) # eledio[\"test2\"] = True # apply final value to hardware eledio.store_outputs() # do something else or wait some time eledio.wait_events(1.0)","title":"Application example"},{"location":"application_example/#example-of-usages","text":"There you can find some examples, how to use python-eledio library in your Eledio devices.","title":"Example of usages"},{"location":"application_example/#state-led-buzzer-and-watchdog-control","text":"","title":"State LED, buzzer and watchdog control"},{"location":"application_example/#configuration-json-file","text":"File name: mpu-config.json { \"devices\": { \"mpu-dev\": { \"bus\": \"mpu\" } }, \"identifiers\": { \"mpuWifiRssi\": { \"unit\": \"mpu-dev\", \"parameter\": \"wifi-rssi\" }, \"mpuInternalTemperature\": { \"unit\": \"mpu-dev\", \"parameter\": \"temperature\" }, \"mpuCpuPercent\": { \"unit\": \"mpu-dev\", \"parameter\": \"cpu-percent\" }, \"mpuLed\": { \"unit\": \"mpu-dev\", \"parameter\": \"led\" }, \"mpuBeeper\": { \"unit\": \"mpu-dev\", \"parameter\": \"beeper\" }, \"mpuWatchdog\": { \"unit\": \"mpu-dev\", \"parameter\": \"watchdog\" } } }","title":"Configuration json file"},{"location":"application_example/#usage","text":"import json from eledio import Eledio from eledio.component.mpu.i2c import SMBus from eledio.device.mpu import MpuFactory if __name__ == \"__main__\": eledio = Eledio() eledio.register_device_factory(\"mpu\", MpuFactory()) with open('mpu-config.json') as f: eledio.append_config(json.load(f)) eledio[\"mpuLed\"] = (0x40, 0x00, 0x00) # set color of state LED in (R, G, B) format eledio[\"mpuBeeper\"] = (1500, 10) # after calling store_outputs() switch on beeper on frequency 1500 Hz for 1s (first parameter is frequency in Hz, second parameter is duration in hundred ms) ''' Warning, next statement is dangerous, it couse restart of linux machine (watchdog). This function is good to use when you have your development complete, and you know, that you communicate with components and devices lower then every x second. ''' eledio[\"mpuWatchdog\"] = 120 # after calling store_outputs() this statement couse reset of linux every 120 seconds. If there is any communication with devicese, timeout is restarted. eledio.store_outputs()","title":"Usage"},{"location":"application_example/#wifi-rssi-linux-cpu-utilization","text":"Use same json file as in previous example.","title":"WiFi RSSI, linux CPU utilization"},{"location":"application_example/#usage_1","text":"import json from eledio import Eledio from eledio.component.mpu.i2c import SMBus from eledio.device.mpu import MpuFactory if __name__ == \"__main__\": eledio = Eledio() eledio.register_device_factory(\"mpu\", MpuFactory()) with open('mpu-config.json') as f: eledio.append_config(json.load(f)) eledio.load_inputs() rssi = eledio[\"mpuWifiRssi\"] # place to variable rssi, WiFi signal RSSI utilization = eledio[\"mpuCpuPercent\"] # place to variable utilitation, linux CPU utilization","title":"Usage"},{"location":"application_example/#srqirq-handler","text":"If you want to used quick access to variables like received code from RF433 control, you can use SRQ handler. Inside SRQ handler, in this example function handle_srq , you received dictionary of eledio identifiers and their new value after SRQ.","title":"SRQ/IRQ handler"},{"location":"application_example/#configuration-json-file_1","text":"File name: map.json { \"devices\": { \"unit-40\": { \"bus\": \"i2c\", \"address\": 40, \"datacrc\": 43200, \"compilermagic\": 4006394777 } }, \"identifiers\": { \"gatewayHWEvent\": { \"unit\": \"unit-40\", \"partition\": \"sdp\", \"offset\": 0, \"entrysize\": 2, \"depth\": 0, \"type\": 1, \"prescaler\": 0, \"a\": 1, \"b\": 0, \"datatype\": \"u16\", \"srq\": 0 }, \"gatewayHWState\": { \"unit\": \"unit-40\", \"partition\": \"sdp\", \"offset\": 2, \"entrysize\": 2, \"depth\": 0, \"type\": 1, \"prescaler\": 0, \"a\": 1, \"b\": 0, \"datatype\": \"u16\" }, \"rf433\": { \"unit\": \"unit-40\", \"partition\": \"sdp\", \"offset\": 4, \"entrysize\": 4, \"depth\": 0, \"type\": 1, \"prescaler\": 0, \"a\": 1, \"b\": 0, \"datatype\": \"u32\", \"srq\": 1 }, \"gatewayHWAction\": { \"unit\": \"unit-40\", \"partition\": \"adp\", \"offset\": 0, \"entrysize\": 2 } } }","title":"Configuration json file"},{"location":"application_example/#usage_2","text":"import json from eledio import Eledio from eledio.component.mpu.i2c import SMBus from eledio.device.mpu import MpuFactory def handle_srq(identifiers): \"\"\" User handling of SRQ (called in context of eledio.wait_events) :param identifiers: dictionary of eledio identifiers and their new value after SRQ :return: \"\"\" print(\"Service requests!\", identifiers) if __name__ == \"__main__\": eledio = Eledio() eledio.register_device_factory(\"i2c\", PcuFactory(SMBus(0))) eledio.register_srq(Srq(), handle_srq()) # repeat for every configuration file with open('map.json') as f: eledio.append_config(json.load(f)) while True: # load state of inputs and outputs eledio.load_inputs() # do something else or wait some time eledio.wait_events(1.0)","title":"Usage"},{"location":"application_example/#error-handler","text":"In runtime and while you develop your solution, there could rise some errors. You can catch them by definition of error handler .","title":"Error handler"},{"location":"application_example/#usage_3","text":"In this example error handler is represented by function handler_error . import json from eledio import Eledio from eledio.component.mpu.i2c import SMBus from eledio.device.pcu import PcuFactory from eledio.device.mpu import MpuFactory from eledio.device.srq import Srq def handle_srq(identifiers): \"\"\" User handling of SRQ (called in context of eledio.wait_events) :param identifiers: dictionary of eledio identifiers and their new value after SRQ :return: \"\"\" print(\"Service requests!\", identifiers) def handle_error(src, ex): \"\"\" Handle error inside eledio library :param src: :param ex: :return: \"\"\" print(src, ex) if __name__ == \"__main__\": eledio = Eledio() eledio.register_device_factory(\"i2c\", PcuFactory(SMBus(0))) eledio.register_device_factory(\"mpu\", MpuFactory()) eledio.register_srq(Srq(), handle_srq) eledio.error_handler = handle_error # repeat for every configuration file with open('config.json') as f: eledio.append_config(json.load(f)) with open('mpu-config.json') as f: eledio.append_config(json.load(f)) while True: # load state of inputs and outputs eledio.load_inputs() # manipulate with inputs and outputs by identifier # e.g. # print(eledio[\"test1\"]) # eledio[\"test2\"] = True # apply final value to hardware eledio.store_outputs() # do something else or wait some time eledio.wait_events(1.0)","title":"Usage"},{"location":"contact/","text":"Contact If you have any question please contact us on email: eledio@eledio.com WWW: eledio.com tel.: +420 724 328 130","title":"Contact"},{"location":"contact/#contact","text":"If you have any question please contact us on email: eledio@eledio.com WWW: eledio.com tel.: +420 724 328 130","title":"Contact"}]}